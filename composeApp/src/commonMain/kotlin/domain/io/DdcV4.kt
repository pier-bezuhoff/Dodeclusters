package domain.io

import androidx.compose.runtime.Immutable
import androidx.compose.ui.graphics.Color
import domain.ColorAsCss
import domain.Ix
import domain.cluster.Constellation
import domain.cluster.LogicalRegion
import domain.expressions.ObjectConstruct
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

// new format idea:
// 1. store coordinates even for expressions, for easier integration with other programs
// 2. store expression as a Map<String, String> for simpler evolution of parameters
// objects:
// - type: Circle | Line | Point | Imaginary circle | null
//   x, y, r | a, b, c
//   expr index
//   expr output index
// ...
// exprs:
// - type: ExprType
//   obj1
//   targetObj
//   param1

// MAYBE: collapse contiguously indexed Expression.OneOf outputs
@Immutable
@Serializable
data class DdcV4(
    val name: String = DEFAULT_NAME,
    val backgroundColor: ColorAsCss? = DEFAULT_BACKGROUND_COLOR,
    val bestCenterX: Float? = DEFAULT_BEST_CENTER_X,
    val bestCenterY: Float? = DEFAULT_BEST_CENTER_Y,
    /** indicates using all-circle chessboard pattern coloring */
    val chessboardPattern: Boolean = DEFAULT_CHESSBOARD_PATTERN,
    /** one of two possible starting chessboard phases, true=colored=bg filled with color */
    val chessboardPatternStartsColored: Boolean = DEFAULT_CHESSBOARD_PATTERN_STARTS_COLORED,
    /** used with chessboard pattern, 2 colors are used: [chessboardColor] and [backgroundColor] */
    val chessboardColor: ColorAsCss? = DEFAULT_CHESSBOARD_COLOR,
    // using Map<Int, _> instead of list to force yaml to use numbered list
    val objects: Map<Ix, Token.Object>, // this disallows missing "objects" field, and produces exception on DdcV3
    val arcPaths: List<Token.ArcPath> = DEFAULT_ARC_PATHS,
    val phantoms: List<Ix> = emptyList(),
) {
    @Immutable
    @Serializable
    sealed interface Token {
        @Serializable
        @SerialName("ObjectToken")
        data class Object(
            val construct: ObjectConstruct,
            val color: ColorAsCss? = null,
        ) : Token
        @Serializable
        @SerialName("ArcPathToken")
        data class ArcPath( // TODO: replace with better suited ArcPath format
            val arcPath: LogicalRegion,
            // intersections, ordered directed circles, fill&border colors, filled or nay
        ) : Token
    }

    fun toConstellation(): Constellation {
        require(objects.keys == (0 until objects.size).toSet()) { "Bad object indices" }
        val objs: List<Token.Object> = objects.entries.sortedBy { it.key }.map { it.value }
        return Constellation(
            objects = objs.map { it.construct },
            parts = arcPaths.map { it.arcPath },
            objectColors = objects.entries
                .mapNotNull { (i, token) ->
                    if (token.color == null) null
                    else i to token.color
                }.toMap()
            ,
            backgroundColor = backgroundColor,
            phantoms = phantoms,
        )
    }

    companion object {
        fun from(constellation: Constellation): DdcV4 =
            DdcV4(
                objects = constellation.objects.mapIndexed { ix, construct ->
                    ix to Token.Object(
                        construct = construct,
                        color = constellation.objectColors[ix],
                    )
                }.toMap(),
                arcPaths = constellation.parts.map { Token.ArcPath(it) },
                backgroundColor = constellation.backgroundColor,
                phantoms = constellation.phantoms,
            )

        const val HEADER = "ddc v4, generated by Dodeclusters"
        const val DEFAULT_NAME = "constellation"
        const val DEFAULT_EXTENSION = "yml"
        val DEFAULT_BACKGROUND_COLOR: Color? = null
        val DEFAULT_BEST_CENTER_X: Float? = null
        val DEFAULT_BEST_CENTER_Y: Float? = null
        const val DEFAULT_CHESSBOARD_PATTERN = false
        const val DEFAULT_CHESSBOARD_PATTERN_STARTS_COLORED = true
        val DEFAULT_CHESSBOARD_COLOR: Color? = null
        val DEFAULT_INITIAL_REGION_COLOR: Color? = null
        val DEFAULT_ARC_PATHS = emptyList<Token.ArcPath>()
    }
}